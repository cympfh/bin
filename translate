#!/usr/bin/env python

import json
import subprocess
import sys

import click
from litellm import completion
from pydantic import BaseModel, Field

LLM_CONFIG = json.loads(
    subprocess.run("llm-config", capture_output=True).stdout.decode("utf-8")
)

LANGS = {
    "unknown": "不明 (与えられる文から推測してください)",
    "ja": "日本語",
    "en": "English",
    "zh": "Chinese",
    "ko": "Korean",
}


class Response(BaseModel):
    model: str = Field(description="Model name used for translation")
    detected_source_language: str = Field(
        description="Detected source language code (e.g., en, ja, zh)"
    )
    target_language: str = Field(description="Target language code")
    text: str = Field(description="Translation result")
    pinyin: str | None = Field(
        default=None, description="Pinyin representation for Chinese text"
    )


class LLM:
    def __init__(self, provider: str, model: str):
        self.model = f"{provider}/{model}"

    def run(
        self, text: str, source_lang: str = "unknown", target_lang: str = "ja"
    ) -> Response:
        source_lang_description = LANGS[source_lang]
        target_lang_description = LANGS[target_lang]
        system_prompt = f"""
自然言語の翻訳をしてください.

翻訳元になる言語: {source_lang_description} ({source_lang.upper()})
翻訳先になる言語: {target_lang_description} ({target_lang.upper()})

ユーザーから文章が与えられます.
文章は
---
から
---
の間にあります.

あなたが返すべき出力は一つの JSON 辞書です.
つまり {{ で始まって }} で終わる文字列のみです.
これ以外のテキストを一切含めないことを厳守してください.
JSON の前後に余計なテキストを出力しないでください.
例えば ```json や ``` といった行は不要です.
このことは厳守してください.

あなたが返すJSONのフォーマットは次です

{{
    "model": "{self.model}",
    "detected_source_language": "${{翻訳元の言語, 例えば EN や JA}}",
    "target_language": "{target_lang.upper()}",
    "text": "${{翻訳結果}}",
    "pinyin": "${{中国語の場合のみ, 普通話での標準的な拼音}}"
}}

では翻訳したい文章を次に与えます.
あなたはその言語の先生になったつもりで, より良い翻訳結果を一つ JSON 形式で示してください.
"""
        messages = [
            {
                "role": "system",
                "content": system_prompt,
            },
            {
                "role": "user",
                "content": f"""
---
{text}
---
""",
            },
        ]
        result = completion(
            model=self.model,
            messages=messages,
            response_format=Response,
        )
        content: str = result.choices[0].message.content  # type: ignore
        return Response.model_validate_json(content)


@click.command()
@click.option(
    "--provider",
    "-p",
    type=click.Choice(["xai", "gemini", "openai", "anthropic"]),
    default=LLM_CONFIG["provider"],
    show_default=True,
)
@click.option(
    "--model",
    "-m",
    type=str,
    default=LLM_CONFIG["model"],
    show_default=True,
)
@click.option("--source", "-s", type=str, default="unknown", help="source language")
@click.option("--target", "-t", type=str, default="ja", help="target language")
@click.argument("text", type=str, required=False)
def main(
    provider: str,
    model: str,
    source: str,
    target: str,
    text: str,
):
    if not text:
        text = sys.stdin.read()

    assert source in LANGS, f"Supported langs: {LANGS}"
    assert target in LANGS, f"Supported langs: {LANGS}"

    result = LLM(provider, model).run(text, source_lang=source, target_lang=target)
    print(result.model_dump_json())


if __name__ == "__main__":
    main()
