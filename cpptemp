#!/bin/sh

if [ "_$1" = "_-h" -o "_$1" = "_--help" ]; then
  cat << USAGE
cpptemp: output the cpp template

  -g,  --geo   template for geometry
  -m,  --min   minimal template
USAGE
  exit
fi

if [ $# -eq 0 ]; then
  # normal template
  cat << TEMP
#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(int i=0;i<(n);++i)
#define loop for(;;)
#define trace(var) cerr<<">>> "<<#var<<" = "<<var<<endl;
#define inf (1e9)
#define eps (1e-9)
using Integer = long long;
using Real = long double;
const Real PI = acosl(-1);
using P = pair<int, int>;

template<class S, class T> inline
ostream& operator<<(ostream&os, pair<S,T> p) {
  return os << '(' << p.first << ", " << p.second << ')';
}

template<class T, class U> inline
ostream& operator<<(ostream&os, tuple<T,U> t) {
  return os << '(' << get<0>(t) << ", " << get<1>(t) << ')';
}

template<class S, class T, class U> inline
ostream& operator<<(ostream&os, tuple<S,T,U> t) {
  return os << '(' << get<0>(t) << ", " << get<1>(t) << ", " << get<2>(t) << ')';
}

template<class T> inline
ostream& operator<<(ostream&os, set<T> v) {
  os << "(set"; for (T item: v) os << ' ' << item; os << ")"; return os;
}

template<class T> inline
ostream& operator<<(ostream&os, vector<T> v) {
  if (v.size() == 0) return os << "(empty)";
  os << v[0]; for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];
  return os;
}

template<class T> inline
istream& operator>>(istream&is, vector<T>&v) {
  rep (i, v.size()) is >> v[i]; return is;
}

//           ^   >  v   <
int dx[] = { -1, 0, 1,  0 };
int dy[] = {  0, 1, 0, -1 };

using vi = vector<int>;
using vvi = vector<vi>;
using vd = vector<double>;
using vvd = vector<vd>;
using vb = vector<bool>;
const string Takahashi = "Takahashi";
const string Aoki = "Aoki";

int main() {
  cin.tie(0);
  ios::sync_with_stdio(0);
  cout.setf(ios::fixed);
  cout.precision(10);
  random_device dev;
  mt19937 rand(dev());

  return 0;
}
TEMP
elif [ "_$1" = "_-g" -o "_$1" = "_--geo" ]; then
  # geometry template
  cat << TEMP
#include <bits/stdc++.h>
using namespace std;

#define rep(i,n) for(int i=0;i<(n);++i)
#define loop for(;;)
#define trace(var) cerr<<">>> "<<#var<<" = "<<var<<endl;
#define inf (1e9)
#define eps (1e-9)
using Integer = long long;
using Real = long double;
const Real PI = acosl(-1);
using P = pair<Real, Real>; // Point
using L = pair<P, P>; // segment or line

template<class S, class T> inline
ostream& operator<<(ostream&os, pair<S,T> p) {
  return os << '(' << p.first << ", " << p.second << ')';
}

template<class T, class U> inline
ostream& operator<<(ostream&os, tuple<T,U> t) {
  return os << '(' << get<0>(t) << ", " << get<1>(t) << ')';
}

template<class S, class T, class U> inline
ostream& operator<<(ostream&os, tuple<S,T,U> t) {
  return os << '(' << get<0>(t) << ", " << get<1>(t) << ", " << get<2>(t) << ')';
}

template<class T> inline
ostream& operator<<(ostream&os, set<T> v) {
  os << "(set"; for (T item: v) os << ' ' << item; os << ")"; return os;
}

template<class T> inline
ostream& operator<<(ostream&os, vector<T> v) {
  if (v.size() == 0) return os << "(empty)";
  os << v[0]; for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];
  return os;
}

template<class T> inline
istream& operator>>(istream&is, vector<T>&v) {
  rep (i, v.size()) is >> v[i]; return is;
}

//           ^   >  v   <
int dx[] = { -1, 0, 1, 0 };
int dy[] = {  0, -1, 0, 1 };

using vi = vector<int>;
using vvi = vector<vi>;
using vd = vector<double>;
using vvd = vector<vd>;
using vb = vector<bool>;

/* inner dot */
Real dot(P&a, P&b) {
  return a.first * b.first + a.second * b.second;
}
Real operator*(P&a, P&b) {
  return a.first * b.first + a.second * b.second;
}

/* scalar multiple */
P operator*(P a, Real c) {
  return {c * a.first, c * a.second};
}
P operator*(Real c, P a) {
  return {c * a.first, c * a.second};
}

P operator/(P a, Real d) {
  return {a.first / d, a.second / d};
}

Real det(P a, P b) {
  return a.first * b.second - a.second * b.first;
}

/* vector operator */
P operator+(P a, P b) {
  return {a.first + b.first, a.second + b.second};
}

P operator-(P a) {
  return {-a.first, -a.second};
}

P operator-(P a, P b) {
  return {a.first - b.first, a.second - b.second};
}

/* distance */
Real Manhattan(P a, P b) {
  return abs(a.first - b.first) + abs(a.second - b.second);
}
Real Euclidean(P a, P b) {
  P p = a - b;
  return sqrt(p.first*p.first + p.second*p.second);
}

/* equality with eps (default: 1e-9) */
bool eq(Real x, Real y) {
  return abs(x - y) < eps;
}
bool operator==(P a, P b) {
  return eq(a.first, b.first) && eq(a.second, b.second);
}

int sign(Real a) {
  if (eq(a, 0)) return 0;
  return a > 0 ? 1 : -1;
}

Real magnitude(P p) {
  return sqrt(p.first*p.first + p.second*p.second);
}

Real arg(P a, P b) {
  Real x = dot(a, b) / magnitude(a) / magnitude(b);
  x = min<Real>(1, max<Real>(-1, x));
  return acos(x);
}

int main() {
  cin.tie(0);
  ios::sync_with_stdio(0);
  cout.setf(ios::fixed);
  cout.precision(10);
  Real a,b,c,d,e,f;

  return 0;
}
TEMP
elif [ "_$1" = "_-m" -o "_$1" = "_--min" ]; then
  # minimal template
  cat << TEMP
#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i=0;i<(n);++i)

int main() {

  return 0;
}
TEMP
fi

