#!/usr/bin/env python

import json
import subprocess
import sys

import click
import watchgod
from litellm import completion
from pydantic import BaseModel, Field

# reasoning モデルをデフォルトに
LLM_CONFIG = json.loads(
    subprocess.run(
        ["llm-config", "xai", "grok-code-fast"], capture_output=True
    ).stdout.decode("utf-8")
)


class CodeOutput(BaseModel):
    language: str = Field(description="Programming language of the code")
    explanation: str = Field(description="Explanation of what the code does")
    code: str = Field(description="Generated or completed code")


class LLM:
    def __init__(self, provider: str, model: str):
        self.model = f"{provider}/{model}"

    def chat(self, language: str, text: str) -> CodeOutput:
        """自然言語で書いてほしいコードを説明する

        生成したコードを得る

        Parameters
        ----------
        language
            プログラミング言語
        text
            説明文
        """
        system_prompt = f"""
プログラミングの手伝いをしてください.
{language} 言語でコーディングをしています.
今からどんなコードを書く必要があるか説明するので, それを実現するコード片を出力してください.

ユーザーは一秒でも早く結果を知りたいので, {language} コードを示す前に御託を述べるような真似は決してしないでください.
そのようなことをする場合, あなたの結果はマイナスに評価されます.
必ず {language} コードのみを出力してください.
コードの前後に ```{language.lower()} や ``` なんかを出力することも本当にやめてください.
"""
        messages = [
            {
                "role": "system",
                "content": system_prompt,
            },
            {
                "role": "user",
                "content": f"""
---
{text}
---
""",
            },
        ]
        result = completion(
            model=self.model,
            messages=messages,
            response_format=CodeOutput,
        )
        content: str = result.choices[0].message.content  # type: ignore
        return CodeOutput.model_validate_json(content)

    def complete(self, language: str, code: str, nosy: str) -> CodeOutput:
        """与えたプログラムコード片のうちプレースホルダーを補完してもらう

        {{ ... }} が補完対象
        生成したコードを得る

        Parameters
        ----------
        language
            プログラミング言語
        code
            プレースホルダーを含むプログラムコード片
        nosy
            お節介モード
            プレースホルダー以外の部分も変更してよい
        """

        nosy_phrase = (
            "あなたは優秀であるとともに非常にお節介なプログラマです. プレースホルダー以外でも明らか誤りがあれば修正してください"
            if nosy
            else "あなたの仕事はプレースホルダーの補完だけです. プレースホルダー以外は絶対に変更しないでください"
        )

        system_prompt = f"""
Goal: プログラミングの手伝い
Method : あなたはするべきことは プレースホルダー の 補完 です

Process:
- ユーザーはプログラミング言語 ({language}) で書いた（書きかけの）コードを示します
- このコードは {{{{ ... }}}} で示されるプレースホルダーを含んでいます
- あなたはプレースホルダーの中身を補完します

Input Example:

---
fn main() {{
    {{{{ Hello, World! をする }}}}
}}

fn is_odd(n: usize) -> bool {{
    if {{{{}}}} {{
        true
    }} else {{
        false
    }}
}}
---

Output Example:

---
fn main() {{
    println!("Hello, World!");
}}

fn is_odd(n: usize) -> bool {{
    if n % 2 == 1 {{
        true
    }} else {{
        false
    }}
}}
---

Placeholder の定義:
{{{{ と }}}} で括られた文字列
{{{{ と }}}} の間には何も無いかもしれないし, ユーザーの指示が自然言語で書かれてるかもしれない.
もし指示があるなら それをヒントに何を書くか考える.
プレースホルダーの中身が空の場合は, 周囲のコードから正しく推測せよ.
あなたは優秀なプログラマです.

Your output:
プレースホルダー全てを埋めたコードを出力する.

Note:
1. プレースホルダーがすべて補完され変更されている.
2. 出力にはもうプレースホルダー {{{{ }}}} が登場しない
3. {nosy_phrase}
"""
        messages = [
            {
                "role": "system",
                "content": system_prompt,
            },
            {
                "role": "user",
                "content": f"""
---
{code}
---
""",
            },
        ]
        result = completion(
            model=self.model,
            messages=messages,
            response_format=CodeOutput,
        )
        content: str = result.choices[0].message.content  # type: ignore
        return CodeOutput.model_validate_json(content)


@click.group()
def main():
    pass


@main.command()
@click.option("--language", "-L", type=str, default="Rust")
@click.option(
    "--provider",
    "-p",
    type=click.Choice(["xai", "gemini", "openai", "anthropic"]),
    default=LLM_CONFIG["provider"],
    show_default=True,
)
@click.option(
    "--model",
    "-m",
    type=str,
    default=LLM_CONFIG["model"],
    show_default=True,
)
@click.option("--quiet", "-q", is_flag=True, default=False)
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    default=None,
    help="Output file path (default: stdout)",
)
@click.argument("text", type=str, required=False)
def chat(
    language: str,
    provider: str,
    model: str,
    quiet: bool,
    output: str | None,
    text: str,
):
    if not text:
        text = sys.stdin.read()
    if not quiet:
        click.secho("Running...", err=True, fg="yellow")
    result = LLM(provider, model).chat(language, text)
    if not quiet:
        click.secho(f"Language: {result.language}", err=True)
        click.secho(f"Explanation: {result.explanation}", err=True)
    if output:
        with open(output, "w") as f:
            f.write(result.code)
    else:
        print(result.code)


@main.command()
@click.option("--language", "-L", type=str, default="?")
@click.option(
    "--provider",
    "-p",
    type=click.Choice(["xai", "gemini", "openai", "anthropic"]),
    default=LLM_CONFIG["provider"],
    show_default=True,
)
@click.option(
    "--model",
    "-m",
    type=str,
    default=LLM_CONFIG["model"],
    show_default=True,
)
@click.option("--quiet", "-q", is_flag=True, default=False)
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    default=None,
    help="Output file path (default: stdout)",
)
@click.option(
    "--watch",
    "-w",
    is_flag=True,
    default=False,
    help="Watch input file for changes and re-run",
)
@click.option("--nosy", "-N", is_flag=True, default=False)
@click.argument("src", type=str, required=False)
def complete(
    language: str,
    provider: str,
    model: str,
    quiet: bool,
    output: str | None,
    watch: bool,
    nosy: bool,
    src: str,
):
    """Complete placeholders in code

    Watches the input file for changes if --watch is specified.
    """
    if watch and not src:
        raise click.UsageError("--watch requires a source file argument")

    def run_completion():
        """Run the completion once"""
        if src:
            code = open(src, "rt").read()
        else:
            code = sys.stdin.read()
        if not quiet:
            click.secho(f"Using {provider}/{model}", err=True, fg="yellow")
            click.secho("Running...", err=True, fg="yellow")
        result = LLM(provider, model).complete(language, code, nosy)
        if not quiet:
            click.secho(f"Language: {result.language}", err=True)
            click.secho(f"Explanation: {result.explanation}", err=True)
        if output:
            with open(output, "w") as f:
                f.write(result.code)
        else:
            print(result.code)

    if watch:
        # Initial run
        run_completion()

        # Watch for changes
        if not quiet:
            click.secho(f"Watching {src} for changes...", err=True, fg="cyan")
        for change in watchgod.watch(src):
            mod_files = [f for _, f in change]
            if not quiet:
                click.secho(f"Modified: {', '.join(mod_files)}", err=True, fg="cyan")
            run_completion()
    else:
        run_completion()


if __name__ == "__main__":
    main()
